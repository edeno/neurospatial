"""
Property-based tests using Hypothesis to verify mathematical invariants.

These tests use randomized inputs to verify that key mathematical properties
hold across a wide range of scenarios. Property-based testing is particularly
valuable for scientific code where mathematical constraints must be maintained.
"""

import networkx as nx
import numpy as np
import pytest
from hypothesis import given, settings
from hypothesis import strategies as st
from hypothesis.extra import numpy as hnp
from numpy.typing import NDArray

from neurospatial import Environment, normalize_field
from neurospatial.alignment import get_2d_rotation_matrix
from neurospatial.transforms import AffineND, from_rotation_matrix


def rotate_2d(angle_radians: float) -> AffineND:
    """
    Helper to create a 2D rotation transform from angle in radians.

    Parameters
    ----------
    angle_radians : float
        Rotation angle in radians

    Returns
    -------
    Affine2D
        2D rotation transformation
    """
    angle_degrees = np.degrees(angle_radians)
    rot_matrix = get_2d_rotation_matrix(angle_degrees)
    return from_rotation_matrix(rot_matrix)


class TestEnvironmentProperties:
    """Property-based tests for Environment mathematical invariants."""

    @given(
        data=hnp.arrays(
            dtype=np.float64,
            shape=hnp.array_shapes(min_dims=2, max_dims=2, min_side=100, max_side=500),
            elements=st.floats(
                min_value=-1000.0,
                max_value=1000.0,
                allow_nan=False,
                allow_infinity=False,
            ),
        ),
        bin_size=st.floats(min_value=1.0, max_value=100.0),
    )
    @settings(max_examples=50, deadline=5000)
    def test_bin_centers_within_data_range(
        self, data: NDArray[np.float64], bin_size: float
    ):
        """
        Property: Bin centers should always be within the input data bounds.

        This is a fundamental spatial discretization invariant - the bins we create
        should cover the data, and bin centers should fall within the data extent.

        Parameters
        ----------
        data : NDArray, shape (n_samples, 2)
            Random 2D point data generated by hypothesis
        bin_size : float
            Random bin size in range [1.0, 100.0]
        """
        # Ensure we have 2D data as required by from_samples
        if data.shape[1] != 2:
            data = data[:, :2]

        # Skip if data is too small or degenerate
        data_range = np.ptp(data, axis=0)
        if np.any(data_range < bin_size) or np.any(data_range < 1e-6):
            pytest.skip("Data range too small for given bin size")

        try:
            env = Environment.from_samples(
                data, bin_size=bin_size, bin_count_threshold=1
            )
        except (ValueError, RuntimeError) as e:
            # Valid to fail if no active bins created
            if "No active bins" in str(e) or "active_mask is all False" in str(e):
                pytest.skip("No active bins created - expected for some random data")
            raise

        # Property: All bin centers should be within data bounds
        # Allow small tolerance (half bin_size) for edge effects
        data_min = np.min(data, axis=0)
        data_max = np.max(data, axis=0)
        tolerance = bin_size / 2.0

        for bin_center in env.bin_centers:
            assert np.all(bin_center >= data_min - tolerance), (
                f"Bin center {bin_center} below data min {data_min}"
            )
            assert np.all(bin_center <= data_max + tolerance), (
                f"Bin center {bin_center} above data max {data_max}"
            )

    @given(
        angle1=st.floats(min_value=-2 * np.pi, max_value=2 * np.pi),
        angle2=st.floats(min_value=-2 * np.pi, max_value=2 * np.pi),
    )
    @settings(max_examples=100, deadline=1000)
    def test_rotation_composition_property(self, angle1: float, angle2: float):
        """
        Property: Composing two rotations should equal a single rotation by the sum.

        Mathematically: R(θ₁) ∘ R(θ₂) = R(θ₁ + θ₂)

        This tests the fundamental group property of rotations and verifies
        our transform composition is mathematically sound.

        Parameters
        ----------
        angle1 : float
            First rotation angle in radians
        angle2 : float
            Second rotation angle in radians
        """
        # Create two rotation transforms
        T1 = rotate_2d(angle1)
        T2 = rotate_2d(angle2)

        # Compose them using @ operator
        T_composed = T1 @ T2

        # Expected: single rotation by sum of angles
        T_expected = rotate_2d(angle1 + angle2)

        # Property: Composed transform should match expected transform
        # Compare the transformation matrices (allowing numerical tolerance)
        np.testing.assert_allclose(
            T_composed.A,
            T_expected.A,
            rtol=1e-10,
            atol=1e-10,
            err_msg=f"Rotation composition failed for angles {angle1}, {angle2}",
        )

    @given(
        n_nodes=st.integers(min_value=5, max_value=30),
        seed=st.integers(min_value=0, max_value=10000),
    )
    @settings(max_examples=50, deadline=5000)
    def test_distance_triangle_inequality(self, n_nodes: int, seed: int):
        """
        Property: Graph distances must satisfy triangle inequality.

        For any three nodes i, j, k: d(i,k) ≤ d(i,j) + d(j,k)

        This is a fundamental property of metric spaces and must hold for
        all shortest path distances in our connectivity graphs.

        Parameters
        ----------
        n_nodes : int
            Number of nodes in the graph
        seed : int
            Random seed for reproducibility
        """
        rng = np.random.default_rng(seed)

        # Create random 2D grid environment
        data = rng.uniform(-50, 50, size=(n_nodes * 5, 2))

        try:
            env = Environment.from_samples(
                data,
                bin_size=10.0,
                bin_count_threshold=1,
                connect_diagonal_neighbors=True,
            )
        except (ValueError, RuntimeError):
            pytest.skip("Could not create valid environment")

        if env.n_bins < 5:
            pytest.skip("Not enough bins for meaningful triangle inequality test")

        # Verify graph is connected (otherwise distances might be infinite)
        if not nx.is_connected(env.connectivity):
            pytest.skip("Graph is not connected")

        # Sample 3 random nodes to test triangle inequality
        # Use at least 3 trials to test different node combinations
        for _ in range(min(3, env.n_bins // 2)):
            # Sample 3 distinct nodes
            node_indices = rng.choice(env.n_bins, size=3, replace=False)
            i, j, k = node_indices

            # Get pairwise distances
            try:
                d_ij = nx.shortest_path_length(
                    env.connectivity, source=i, target=j, weight="distance"
                )
                d_jk = nx.shortest_path_length(
                    env.connectivity, source=j, target=k, weight="distance"
                )
                d_ik = nx.shortest_path_length(
                    env.connectivity, source=i, target=k, weight="distance"
                )
            except nx.NetworkXNoPath:
                # Nodes not connected - skip this combination
                continue

            # Property: Triangle inequality must hold
            # Allow small numerical tolerance for floating point arithmetic
            tolerance = 1e-10
            assert d_ik <= d_ij + d_jk + tolerance, (
                f"Triangle inequality violated: d({i},{k})={d_ik} > d({i},{j})+d({j},{k})={d_ij + d_jk}"
            )

    @given(
        n_bins=st.integers(min_value=20, max_value=100),
        seed=st.integers(min_value=0, max_value=10000),
    )
    @settings(max_examples=50, deadline=5000)
    def test_connectivity_graph_is_undirected(self, n_bins: int, seed: int):
        """
        Property: Connectivity graph must be undirected (symmetric edges).

        For spatial environments, if bin A is a neighbor of bin B,
        then bin B must be a neighbor of bin A. This is a fundamental
        property of spatial adjacency.

        Mathematically: (i, j) ∈ E ⟺ (j, i) ∈ E

        Parameters
        ----------
        n_bins : int
            Target number of bins to generate
        seed : int
            Random seed for reproducibility
        """
        rng = np.random.default_rng(seed)

        # Create environment with known number of bins
        n_samples = n_bins * 10
        data = rng.uniform(-50, 50, size=(n_samples, 2))

        try:
            env = Environment.from_samples(
                data,
                bin_size=5.0,
                bin_count_threshold=1,
                connect_diagonal_neighbors=True,
            )
        except (ValueError, RuntimeError):
            pytest.skip("Could not create valid environment")

        if env.n_bins < 5:
            pytest.skip("Not enough bins for meaningful symmetry test")

        # Property: Graph must be undirected
        # For every edge (i, j), there must exist edge (j, i)
        for edge in env.connectivity.edges():
            i, j = edge
            # Check reverse edge exists
            assert env.connectivity.has_edge(j, i), (
                f"Graph not undirected: edge ({i},{j}) exists but ({j},{i}) doesn't"
            )

            # Check edge attributes match (distance, etc.)
            dist_ij = env.connectivity.edges[i, j]["distance"]
            dist_ji = env.connectivity.edges[j, i]["distance"]
            np.testing.assert_allclose(
                dist_ij,
                dist_ji,
                rtol=1e-10,
                atol=1e-10,
                err_msg=f"Edge distances not symmetric: d({i},{j})={dist_ij} ≠ d({j},{i})={dist_ji}",
            )

    @given(
        field_size=st.integers(min_value=10, max_value=100),
        seed=st.integers(min_value=0, max_value=10000),
    )
    @settings(max_examples=50, deadline=3000)
    def test_normalized_field_sums_to_one(self, field_size: int, seed: int):
        """
        Property: Normalized spatial fields should sum to 1 (probability mass).

        When a spatial field is normalized, it represents a probability distribution
        over space. The total probability must sum to 1.

        This tests both the normalize_field method and the underlying mathematical
        correctness of probability normalization.

        Parameters
        ----------
        field_size : int
            Number of bins in the environment
        seed : int
            Random seed for reproducibility
        """
        rng = np.random.default_rng(seed)

        # Create environment with known number of bins
        n_samples = field_size * 5
        data = rng.uniform(-50, 50, size=(n_samples, 2))

        try:
            env = Environment.from_samples(
                data,
                bin_size=10.0,
                bin_count_threshold=1,
            )
        except (ValueError, RuntimeError):
            pytest.skip("Could not create valid environment")

        if env.n_bins < 5:
            pytest.skip("Not enough bins for meaningful normalization test")

        # Generate random non-negative field (like a firing rate map)
        # Use exponential to ensure non-negative values
        field = rng.exponential(scale=2.0, size=env.n_bins)

        # Normalize the field
        try:
            normalized = normalize_field(field)
        except (ValueError, ZeroDivisionError):
            # Valid to fail if field is all zeros
            if np.all(field == 0):
                pytest.skip("All-zero field cannot be normalized")
            raise

        # Property: Normalized field should sum to 1 (probability mass)
        field_sum = np.sum(normalized)
        np.testing.assert_allclose(
            field_sum,
            1.0,
            rtol=1e-10,
            atol=1e-10,
            err_msg=f"Normalized field sums to {field_sum}, expected 1.0",
        )

        # Additional property: All values should be non-negative (valid probability)
        assert np.all(normalized >= 0), "Normalized field has negative values"


class TestTransformProperties:
    """Property-based tests for transformation mathematical properties."""

    @given(
        angle=st.floats(min_value=-2 * np.pi, max_value=2 * np.pi),
        point_x=st.floats(min_value=-100.0, max_value=100.0),
        point_y=st.floats(min_value=-100.0, max_value=100.0),
    )
    @settings(max_examples=100, deadline=1000)
    def test_rotation_preserves_distance_from_origin(
        self, angle: float, point_x: float, point_y: float
    ):
        """
        Property: Rotation preserves distance from origin.

        Rotations are isometries - they preserve distances. Specifically,
        rotating a point should not change its distance from the origin.

        Mathematically: ||R(p)|| = ||p|| for any rotation R and point p.

        Parameters
        ----------
        angle : float
            Rotation angle in radians
        point_x, point_y : float
            2D point coordinates
        """
        point = np.array([point_x, point_y])

        # Distance before rotation
        dist_before = np.linalg.norm(point)

        # Apply rotation using __call__ (Affine2D is callable)
        T = rotate_2d(angle)
        rotated_point = T(point.reshape(1, 2))[0]

        # Distance after rotation
        dist_after = np.linalg.norm(rotated_point)

        # Property: Distance should be preserved (isometry)
        np.testing.assert_allclose(
            dist_after,
            dist_before,
            rtol=1e-10,
            atol=1e-10,
            err_msg=f"Rotation changed distance: {dist_before} -> {dist_after}",
        )

    @given(
        angle=st.floats(min_value=-2 * np.pi, max_value=2 * np.pi),
    )
    @settings(max_examples=50, deadline=1000)
    def test_rotation_inverse_property(self, angle: float):
        """
        Property: Applying a rotation and its inverse should return to identity.

        Mathematically: R(θ) ∘ R(-θ) = I (identity)

        This tests that our rotation composition and inversion are correct.

        Parameters
        ----------
        angle : float
            Rotation angle in radians
        """
        # Create rotation and its inverse
        T = rotate_2d(angle)
        T_inv = rotate_2d(-angle)

        # Compose them using @ operator
        T_composed = T @ T_inv

        # Expected: Identity transformation (identity has matrix [[1,0,0],[0,1,0],[0,0,1]])
        identity_matrix = np.eye(3)

        # Property: Composition should equal identity
        np.testing.assert_allclose(
            T_composed.A,
            identity_matrix,
            rtol=1e-10,
            atol=1e-10,
            err_msg=f"R({angle}) ∘ R({-angle}) ≠ I",
        )
